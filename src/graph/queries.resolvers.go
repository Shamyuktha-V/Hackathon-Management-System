package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"Hackathon-Management-System/src/auth"
	"Hackathon-Management-System/src/graph/model"
	"context"
	"fmt"

	"github.com/google/uuid"
)

// GetCurrentHackathons is the resolver for the GetCurrentHackathons field.
func (r *queryResolver) GetCurrentHackathons(ctx context.Context) ([]*model.Hackathon, error) {
	hackathons, err := r.HackathonService.GetHackathonsAvailableForRegistration(ctx)
	if err != nil {
		return nil, err
	}
	return hackathons, nil
}

// GetFutureHackathons is the resolver for the GetFutureHackathons field.
func (r *queryResolver) GetFutureHackathons(ctx context.Context) ([]*model.Hackathon, error) {
	hackathons, err := r.HackathonService.GetFutureHackathons(ctx)
	if err != nil {
		return nil, err
	}
	return hackathons, nil
}

// GetHackathonByCategory is the resolver for the GetHackathonByCategory field.
func (r *queryResolver) GetHackathonByCategory(ctx context.Context, id string) ([]*model.Hackathon, error) {
	uuid, _ := uuid.Parse(id)
	hackathons, err := r.HackathonService.GetHackathonByCategory(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return hackathons, nil
}

// GetHackathonByDuration is the resolver for the GetHackathonByDuration field.
func (r *queryResolver) GetHackathonByDuration(ctx context.Context, duration int) ([]*model.Hackathon, error) {
	hackathons, err := r.HackathonService.GetHackathonsByAttributes(ctx, nil, nil, nil, nil, nil, nil, &duration)
	if err != nil {
		return nil, err
	}
	return hackathons, nil
}

// GetCategories is the resolver for the GetCategories field.
func (r *queryResolver) GetCategories(ctx context.Context) ([]*model.Category, error) {
	category, err := r.CategoryService.GetAllCategories(ctx)
	if err != nil {
		return nil, err
	}
	return category, nil
}

// GetUserHackathons is the resolver for the GetUserHackathons field.
func (r *queryResolver) GetUserHackathons(ctx context.Context) ([]*model.Submission, error) {
	user, err := auth.GetUser(ctx, r.AppConfig)
	if err != nil {
		return nil, err
	}
	userID, _ := uuid.Parse(user.ID)
	if user.Role == "judge" {
		hackathon, err := r.HackathonService.GetHackathonsByAttributes(ctx, &userID, nil, nil, nil, nil, nil, nil)
		if err != nil {
			return nil, err
		}
		var hackathons []*model.Submission
		for _, hack := range hackathon {
			hackID, _ := uuid.Parse(hack.ID)
			submissions, err := r.SubmissionService.GetTeamsForAHackathons(ctx, hackID)
			if err != nil {
				return nil, err
			}
			hackathons = append(hackathons, submissions...)
		}
		return hackathons, nil
	} else if user.Role == "participant" {
		teams, err := r.TeamMemberService.GetTeamMembersByUserID(ctx, userID)
		if err != nil {
			return nil, err
		}
		var hackathons []*model.Submission
		for _, team := range teams {
			teamId, _ := uuid.Parse(team.TeamID)
			submissions, err := r.SubmissionService.GetHackathonsForATeam(ctx, teamId)
			if err != nil {
				return nil, err
			}
			hackathons = append(hackathons, submissions...)
		}
		return hackathons, nil
	}
	return nil, fmt.Errorf("You are not authorized to perform this action")
}

// GetAllTeamsForAHackathon is the resolver for the GetAllTeamsForAHackathon field.
func (r *queryResolver) GetAllTeamsForAHackathon(ctx context.Context, hackathonID string) ([]*model.Submission, error) {
	uuid, _ := uuid.Parse(hackathonID)
	teams, err := r.SubmissionService.GetTeamsForAHackathons(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return teams, nil
}

// GetMembersForATeam is the resolver for the GetMembersForATeam field.
func (r *queryResolver) GetMembersForATeam(ctx context.Context, teamID string) ([]*model.TeamMember, error) {
	uuid, _ := uuid.Parse(teamID)
	teams, err := r.TeamMemberService.GetTeamMembersByTeamID(ctx, uuid)
	if err != nil {
		return nil, err
	}
	return teams, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
